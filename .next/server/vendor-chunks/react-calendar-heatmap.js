"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-calendar-heatmap";
exports.ids = ["vendor-chunks/react-calendar-heatmap"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-calendar-heatmap/dist/styles.css":
/*!*************************************************************!*\
  !*** ./node_modules/react-calendar-heatmap/dist/styles.css ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"36fe667a9728\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FsZW5kYXItaGVhdG1hcC9kaXN0L3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZXRzY29kZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1jYWxlbmRhci1oZWF0bWFwL2Rpc3Qvc3R5bGVzLmNzcz84MWMxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMzZmZTY2N2E5NzI4XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-calendar-heatmap/dist/styles.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-calendar-heatmap/dist/react-calendar-heatmap.cjs.js":
/*!********************************************************************************!*\
  !*** ./node_modules/react-calendar-heatmap/dist/react-calendar-heatmap.cjs.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = _interopDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nvar ReactPropTypesSecret_1 = ReactPropTypesSecret;\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nvar factoryWithThrowingShims = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret_1) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  }  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  }  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\nvar propTypes = createCommonjsModule(function (module) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n{\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = factoryWithThrowingShims();\n}\n});\n\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nvar MILLISECONDS_IN_ONE_DAY = 24 * 60 * 60 * 1000;\nvar DAYS_IN_WEEK = 7;\nvar MONTH_LABELS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nvar DAY_LABELS = ['', 'Mon', '', 'Wed', '', 'Fri', ''];\n\n// returns a new date shifted a certain number of days (can be negative)\nfunction shiftDate(date, numDays) {\n  var newDate = new Date(date);\n  newDate.setDate(newDate.getDate() + numDays);\n  return newDate;\n}\nfunction getBeginningTimeForDate(date) {\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n} // obj can be a parseable string, a millisecond timestamp, or a Date object\n\nfunction convertToDate(obj) {\n  return obj instanceof Date ? obj : new Date(obj);\n}\nfunction dateNDaysAgo(numDaysAgo) {\n  return shiftDate(new Date(), -numDaysAgo);\n}\nfunction getRange(count) {\n  var arr = [];\n\n  for (var idx = 0; idx < count; idx += 1) {\n    arr.push(idx);\n  }\n\n  return arr;\n}\n\nvar SQUARE_SIZE = 10;\nvar MONTH_LABEL_GUTTER_SIZE = 4;\nvar CSS_PSEDUO_NAMESPACE = 'react-calendar-heatmap-';\n\nvar CalendarHeatmap =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(CalendarHeatmap, _React$Component);\n\n  function CalendarHeatmap() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, CalendarHeatmap);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CalendarHeatmap)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"getValueCache\", memoizeOne(function (props) {\n      return props.values.reduce(function (memo, value) {\n        var date = convertToDate(value.date);\n        var index = Math.floor((date - _this.getStartDateWithEmptyDays()) / MILLISECONDS_IN_ONE_DAY); // eslint-disable-next-line no-param-reassign\n\n        memo[index] = {\n          value: value,\n          className: _this.props.classForValue(value),\n          title: _this.props.titleForValue ? _this.props.titleForValue(value) : null,\n          tooltipDataAttrs: _this.getTooltipDataAttrsForValue(value)\n        };\n        return memo;\n      }, {});\n    }));\n\n    return _this;\n  }\n\n  _createClass(CalendarHeatmap, [{\n    key: \"getDateDifferenceInDays\",\n    value: function getDateDifferenceInDays() {\n      var _this$props = this.props,\n          startDate = _this$props.startDate,\n          numDays = _this$props.numDays;\n\n      if (numDays) {\n        // eslint-disable-next-line no-console\n        console.warn('numDays is a deprecated prop. It will be removed in the next release. Consider using the startDate prop instead.');\n        return numDays;\n      }\n\n      var timeDiff = this.getEndDate() - convertToDate(startDate);\n      return Math.ceil(timeDiff / MILLISECONDS_IN_ONE_DAY);\n    }\n  }, {\n    key: \"getSquareSizeWithGutter\",\n    value: function getSquareSizeWithGutter() {\n      return SQUARE_SIZE + this.props.gutterSize;\n    }\n  }, {\n    key: \"getMonthLabelSize\",\n    value: function getMonthLabelSize() {\n      if (!this.props.showMonthLabels) {\n        return 0;\n      }\n\n      if (this.props.horizontal) {\n        return SQUARE_SIZE + MONTH_LABEL_GUTTER_SIZE;\n      }\n\n      return 2 * (SQUARE_SIZE + MONTH_LABEL_GUTTER_SIZE);\n    }\n  }, {\n    key: \"getWeekdayLabelSize\",\n    value: function getWeekdayLabelSize() {\n      if (!this.props.showWeekdayLabels) {\n        return 0;\n      }\n\n      if (this.props.horizontal) {\n        return 30;\n      }\n\n      return SQUARE_SIZE * 1.5;\n    }\n  }, {\n    key: \"getStartDate\",\n    value: function getStartDate() {\n      return shiftDate(this.getEndDate(), -this.getDateDifferenceInDays() + 1); // +1 because endDate is inclusive\n    }\n  }, {\n    key: \"getEndDate\",\n    value: function getEndDate() {\n      return getBeginningTimeForDate(convertToDate(this.props.endDate));\n    }\n  }, {\n    key: \"getStartDateWithEmptyDays\",\n    value: function getStartDateWithEmptyDays() {\n      return shiftDate(this.getStartDate(), -this.getNumEmptyDaysAtStart());\n    }\n  }, {\n    key: \"getNumEmptyDaysAtStart\",\n    value: function getNumEmptyDaysAtStart() {\n      return this.getStartDate().getDay();\n    }\n  }, {\n    key: \"getNumEmptyDaysAtEnd\",\n    value: function getNumEmptyDaysAtEnd() {\n      return DAYS_IN_WEEK - 1 - this.getEndDate().getDay();\n    }\n  }, {\n    key: \"getWeekCount\",\n    value: function getWeekCount() {\n      var numDaysRoundedToWeek = this.getDateDifferenceInDays() + this.getNumEmptyDaysAtStart() + this.getNumEmptyDaysAtEnd();\n      return Math.ceil(numDaysRoundedToWeek / DAYS_IN_WEEK);\n    }\n  }, {\n    key: \"getWeekWidth\",\n    value: function getWeekWidth() {\n      return DAYS_IN_WEEK * this.getSquareSizeWithGutter();\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.getWeekCount() * this.getSquareSizeWithGutter() - (this.props.gutterSize - this.getWeekdayLabelSize());\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.getWeekWidth() + (this.getMonthLabelSize() - this.props.gutterSize) + this.getWeekdayLabelSize();\n    }\n  }, {\n    key: \"getValueForIndex\",\n    value: function getValueForIndex(index) {\n      if (this.valueCache[index]) {\n        return this.valueCache[index].value;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getClassNameForIndex\",\n    value: function getClassNameForIndex(index) {\n      if (this.valueCache[index]) {\n        return this.valueCache[index].className;\n      }\n\n      return this.props.classForValue(null);\n    }\n  }, {\n    key: \"getTitleForIndex\",\n    value: function getTitleForIndex(index) {\n      if (this.valueCache[index]) {\n        return this.valueCache[index].title;\n      }\n\n      return this.props.titleForValue ? this.props.titleForValue(null) : null;\n    }\n  }, {\n    key: \"getTooltipDataAttrsForIndex\",\n    value: function getTooltipDataAttrsForIndex(index) {\n      if (this.valueCache[index]) {\n        return this.valueCache[index].tooltipDataAttrs;\n      }\n\n      return this.getTooltipDataAttrsForValue({\n        date: null,\n        count: null\n      });\n    }\n  }, {\n    key: \"getTooltipDataAttrsForValue\",\n    value: function getTooltipDataAttrsForValue(value) {\n      var tooltipDataAttrs = this.props.tooltipDataAttrs;\n\n      if (typeof tooltipDataAttrs === 'function') {\n        return tooltipDataAttrs(value);\n      }\n\n      return tooltipDataAttrs;\n    }\n  }, {\n    key: \"getTransformForWeek\",\n    value: function getTransformForWeek(weekIndex) {\n      if (this.props.horizontal) {\n        return \"translate(\".concat(weekIndex * this.getSquareSizeWithGutter(), \", 0)\");\n      }\n\n      return \"translate(0, \".concat(weekIndex * this.getSquareSizeWithGutter(), \")\");\n    }\n  }, {\n    key: \"getTransformForWeekdayLabels\",\n    value: function getTransformForWeekdayLabels() {\n      if (this.props.horizontal) {\n        return \"translate(\".concat(SQUARE_SIZE, \", \").concat(this.getMonthLabelSize(), \")\");\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getTransformForMonthLabels\",\n    value: function getTransformForMonthLabels() {\n      if (this.props.horizontal) {\n        return \"translate(\".concat(this.getWeekdayLabelSize(), \", 0)\");\n      }\n\n      return \"translate(\".concat(this.getWeekWidth() + MONTH_LABEL_GUTTER_SIZE, \", \").concat(this.getWeekdayLabelSize(), \")\");\n    }\n  }, {\n    key: \"getTransformForAllWeeks\",\n    value: function getTransformForAllWeeks() {\n      if (this.props.horizontal) {\n        return \"translate(\".concat(this.getWeekdayLabelSize(), \", \").concat(this.getMonthLabelSize(), \")\");\n      }\n\n      return \"translate(0, \".concat(this.getWeekdayLabelSize(), \")\");\n    }\n  }, {\n    key: \"getViewBox\",\n    value: function getViewBox() {\n      if (this.props.horizontal) {\n        return \"0 0 \".concat(this.getWidth(), \" \").concat(this.getHeight());\n      }\n\n      return \"0 0 \".concat(this.getHeight(), \" \").concat(this.getWidth());\n    }\n  }, {\n    key: \"getSquareCoordinates\",\n    value: function getSquareCoordinates(dayIndex) {\n      if (this.props.horizontal) {\n        return [0, dayIndex * this.getSquareSizeWithGutter()];\n      }\n\n      return [dayIndex * this.getSquareSizeWithGutter(), 0];\n    }\n  }, {\n    key: \"getWeekdayLabelCoordinates\",\n    value: function getWeekdayLabelCoordinates(dayIndex) {\n      if (this.props.horizontal) {\n        return [0, (dayIndex + 1) * SQUARE_SIZE + dayIndex * this.props.gutterSize];\n      }\n\n      return [dayIndex * SQUARE_SIZE + dayIndex * this.props.gutterSize, SQUARE_SIZE];\n    }\n  }, {\n    key: \"getMonthLabelCoordinates\",\n    value: function getMonthLabelCoordinates(weekIndex) {\n      if (this.props.horizontal) {\n        return [weekIndex * this.getSquareSizeWithGutter(), this.getMonthLabelSize() - MONTH_LABEL_GUTTER_SIZE];\n      }\n\n      var verticalOffset = -2;\n      return [0, (weekIndex + 1) * this.getSquareSizeWithGutter() + verticalOffset];\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(value) {\n      if (this.props.onClick) {\n        this.props.onClick(value);\n      }\n    }\n  }, {\n    key: \"handleMouseOver\",\n    value: function handleMouseOver(e, value) {\n      if (this.props.onMouseOver) {\n        this.props.onMouseOver(e, value);\n      }\n    }\n  }, {\n    key: \"handleMouseLeave\",\n    value: function handleMouseLeave(e, value) {\n      if (this.props.onMouseLeave) {\n        this.props.onMouseLeave(e, value);\n      }\n    }\n  }, {\n    key: \"renderSquare\",\n    value: function renderSquare(dayIndex, index) {\n      var _this2 = this;\n\n      var indexOutOfRange = index < this.getNumEmptyDaysAtStart() || index >= this.getNumEmptyDaysAtStart() + this.getDateDifferenceInDays();\n\n      if (indexOutOfRange && !this.props.showOutOfRangeDays) {\n        return null;\n      }\n\n      var _this$getSquareCoordi = this.getSquareCoordinates(dayIndex),\n          _this$getSquareCoordi2 = _slicedToArray(_this$getSquareCoordi, 2),\n          x = _this$getSquareCoordi2[0],\n          y = _this$getSquareCoordi2[1];\n\n      var value = this.getValueForIndex(index);\n      var rect = // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events\n      React.createElement(\"rect\", _extends({\n        key: index,\n        width: SQUARE_SIZE,\n        height: SQUARE_SIZE,\n        x: x,\n        y: y,\n        className: this.getClassNameForIndex(index),\n        onClick: function onClick() {\n          return _this2.handleClick(value);\n        },\n        onMouseOver: function onMouseOver(e) {\n          return _this2.handleMouseOver(e, value);\n        },\n        onMouseLeave: function onMouseLeave(e) {\n          return _this2.handleMouseLeave(e, value);\n        }\n      }, this.getTooltipDataAttrsForIndex(index)), React.createElement(\"title\", null, this.getTitleForIndex(index)));\n      var transformDayElement = this.props.transformDayElement;\n      return transformDayElement ? transformDayElement(rect, value, index) : rect;\n    }\n  }, {\n    key: \"renderWeek\",\n    value: function renderWeek(weekIndex) {\n      var _this3 = this;\n\n      return React.createElement(\"g\", {\n        key: weekIndex,\n        transform: this.getTransformForWeek(weekIndex),\n        className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"week\")\n      }, getRange(DAYS_IN_WEEK).map(function (dayIndex) {\n        return _this3.renderSquare(dayIndex, weekIndex * DAYS_IN_WEEK + dayIndex);\n      }));\n    }\n  }, {\n    key: \"renderAllWeeks\",\n    value: function renderAllWeeks() {\n      var _this4 = this;\n\n      return getRange(this.getWeekCount()).map(function (weekIndex) {\n        return _this4.renderWeek(weekIndex);\n      });\n    }\n  }, {\n    key: \"renderMonthLabels\",\n    value: function renderMonthLabels() {\n      var _this5 = this;\n\n      if (!this.props.showMonthLabels) {\n        return null;\n      }\n\n      var weekRange = getRange(this.getWeekCount() - 1); // don't render for last week, because label will be cut off\n\n      return weekRange.map(function (weekIndex) {\n        var endOfWeek = shiftDate(_this5.getStartDateWithEmptyDays(), (weekIndex + 1) * DAYS_IN_WEEK);\n\n        var _this5$getMonthLabelC = _this5.getMonthLabelCoordinates(weekIndex),\n            _this5$getMonthLabelC2 = _slicedToArray(_this5$getMonthLabelC, 2),\n            x = _this5$getMonthLabelC2[0],\n            y = _this5$getMonthLabelC2[1];\n\n        return endOfWeek.getDate() >= 1 && endOfWeek.getDate() <= DAYS_IN_WEEK ? React.createElement(\"text\", {\n          key: weekIndex,\n          x: x,\n          y: y,\n          className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"month-label\")\n        }, _this5.props.monthLabels[endOfWeek.getMonth()]) : null;\n      });\n    }\n  }, {\n    key: \"renderWeekdayLabels\",\n    value: function renderWeekdayLabels() {\n      var _this6 = this;\n\n      if (!this.props.showWeekdayLabels) {\n        return null;\n      }\n\n      return this.props.weekdayLabels.map(function (weekdayLabel, dayIndex) {\n        var _this6$getWeekdayLabe = _this6.getWeekdayLabelCoordinates(dayIndex),\n            _this6$getWeekdayLabe2 = _slicedToArray(_this6$getWeekdayLabe, 2),\n            x = _this6$getWeekdayLabe2[0],\n            y = _this6$getWeekdayLabe2[1];\n\n        var cssClasses = \"\".concat(_this6.props.horizontal ? '' : \"\".concat(CSS_PSEDUO_NAMESPACE, \"small-text\"), \" \").concat(CSS_PSEDUO_NAMESPACE, \"weekday-label\"); // eslint-disable-next-line no-bitwise\n\n        return dayIndex & 1 ? React.createElement(\"text\", {\n          key: \"\".concat(x).concat(y),\n          x: x,\n          y: y,\n          className: cssClasses\n        }, weekdayLabel) : null;\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.valueCache = this.getValueCache(this.props);\n      return React.createElement(\"svg\", {\n        className: \"react-calendar-heatmap\",\n        viewBox: this.getViewBox()\n      }, React.createElement(\"g\", {\n        transform: this.getTransformForMonthLabels(),\n        className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"month-labels\")\n      }, this.renderMonthLabels()), React.createElement(\"g\", {\n        transform: this.getTransformForAllWeeks(),\n        className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"all-weeks\")\n      }, this.renderAllWeeks()), React.createElement(\"g\", {\n        transform: this.getTransformForWeekdayLabels(),\n        className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"weekday-labels\")\n      }, this.renderWeekdayLabels()));\n    }\n  }]);\n\n  return CalendarHeatmap;\n}(React.Component);\n\nCalendarHeatmap.propTypes = {\n  values: propTypes.arrayOf(propTypes.shape({\n    date: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.instanceOf(Date)]).isRequired\n  }).isRequired).isRequired,\n  // array of objects with date and arbitrary metadata\n  numDays: propTypes.number,\n  // number of days back from endDate to show\n  startDate: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.instanceOf(Date)]),\n  // start of date range\n  endDate: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.instanceOf(Date)]),\n  // end of date range\n  gutterSize: propTypes.number,\n  // size of space between squares\n  horizontal: propTypes.bool,\n  // whether to orient horizontally or vertically\n  showMonthLabels: propTypes.bool,\n  // whether to show month labels\n  showWeekdayLabels: propTypes.bool,\n  // whether to show weekday labels\n  showOutOfRangeDays: propTypes.bool,\n  // whether to render squares for extra days in week after endDate, and before start date\n  tooltipDataAttrs: propTypes.oneOfType([propTypes.object, propTypes.func]),\n  // data attributes to add to square for setting 3rd party tooltips, e.g. { 'data-toggle': 'tooltip' } for bootstrap tooltips\n  titleForValue: propTypes.func,\n  // function which returns title text for value\n  classForValue: propTypes.func,\n  // function which returns html class for value\n  monthLabels: propTypes.arrayOf(propTypes.string),\n  // An array with 12 strings representing the text from janurary to december\n  weekdayLabels: propTypes.arrayOf(propTypes.string),\n  // An array with 7 strings representing the text from Sun to Sat\n  onClick: propTypes.func,\n  // callback function when a square is clicked\n  onMouseOver: propTypes.func,\n  // callback function when mouse pointer is over a square\n  onMouseLeave: propTypes.func,\n  // callback function when mouse pointer is left a square\n  transformDayElement: propTypes.func // function to further transform the svg element for a single day\n\n};\nCalendarHeatmap.defaultProps = {\n  numDays: null,\n  startDate: dateNDaysAgo(200),\n  endDate: new Date(),\n  gutterSize: 1,\n  horizontal: true,\n  showMonthLabels: true,\n  showWeekdayLabels: false,\n  showOutOfRangeDays: false,\n  tooltipDataAttrs: null,\n  titleForValue: null,\n  classForValue: function classForValue(value) {\n    return value ? 'color-filled' : 'color-empty';\n  },\n  monthLabels: MONTH_LABELS,\n  weekdayLabels: DAY_LABELS,\n  onClick: null,\n  onMouseOver: null,\n  onMouseLeave: null,\n  transformDayElement: null\n};\n\nmodule.exports = CalendarHeatmap;\n//# sourceMappingURL=react-calendar-heatmap.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FsZW5kYXItaGVhdG1hcC9kaXN0L3JlYWN0LWNhbGVuZGFyLWhlYXRtYXAuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdDQUFnQzs7QUFFaEMsNEJBQTRCLG1CQUFPLENBQUMsd0dBQU87O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsK0JBQStCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7O0FBRXRHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1gsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQ7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFLQUFxSzs7QUFFcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwyQkFBMkI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xldHNjb2RlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWNhbGVuZGFyLWhlYXRtYXAvZGlzdC9yZWFjdC1jYWxlbmRhci1oZWF0bWFwLmNqcy5qcz9mZWZiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBSZWFjdCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdyZWFjdCcpKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICghKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25XaXRoUmVzZXQoKSB7fVxuZW1wdHlGdW5jdGlvbldpdGhSZXNldC5yZXNldFdhcm5pbmdDYWNoZSA9IGVtcHR5RnVuY3Rpb247XG5cbnZhciBmYWN0b3J5V2l0aFRocm93aW5nU2hpbXMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9ICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9ICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgZWxlbWVudFR5cGU6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbSxcblxuICAgIGNoZWNrUHJvcFR5cGVzOiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LFxuICAgIHJlc2V0V2FybmluZ0NhY2hlOiBlbXB0eUZ1bmN0aW9uXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxudmFyIHByb3BUeXBlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxue1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zKCk7XG59XG59KTtcblxuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV3SW5wdXRzLCBsYXN0SW5wdXRzKSB7XG4gICAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5ld0lucHV0c1tpXSAhPT0gbGFzdElucHV0c1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplT25lKHJlc3VsdEZuLCBpc0VxdWFsKSB7XG4gICAgaWYgKGlzRXF1YWwgPT09IHZvaWQgMCkgeyBpc0VxdWFsID0gYXJlSW5wdXRzRXF1YWw7IH1cbiAgICB2YXIgbGFzdFRoaXM7XG4gICAgdmFyIGxhc3RBcmdzID0gW107XG4gICAgdmFyIGxhc3RSZXN1bHQ7XG4gICAgdmFyIGNhbGxlZE9uY2UgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBpc0VxdWFsKG5ld0FyZ3MsIGxhc3RBcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICBjYWxsZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0QXJncyA9IG5ld0FyZ3M7XG4gICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fT05FX0RBWSA9IDI0ICogNjAgKiA2MCAqIDEwMDA7XG52YXIgREFZU19JTl9XRUVLID0gNztcbnZhciBNT05USF9MQUJFTFMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG52YXIgREFZX0xBQkVMUyA9IFsnJywgJ01vbicsICcnLCAnV2VkJywgJycsICdGcmknLCAnJ107XG5cbi8vIHJldHVybnMgYSBuZXcgZGF0ZSBzaGlmdGVkIGEgY2VydGFpbiBudW1iZXIgb2YgZGF5cyAoY2FuIGJlIG5lZ2F0aXZlKVxuZnVuY3Rpb24gc2hpZnREYXRlKGRhdGUsIG51bURheXMpIHtcbiAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgbmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpICsgbnVtRGF5cyk7XG4gIHJldHVybiBuZXdEYXRlO1xufVxuZnVuY3Rpb24gZ2V0QmVnaW5uaW5nVGltZUZvckRhdGUoZGF0ZSkge1xuICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbn0gLy8gb2JqIGNhbiBiZSBhIHBhcnNlYWJsZSBzdHJpbmcsIGEgbWlsbGlzZWNvbmQgdGltZXN0YW1wLCBvciBhIERhdGUgb2JqZWN0XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0RhdGUob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBEYXRlID8gb2JqIDogbmV3IERhdGUob2JqKTtcbn1cbmZ1bmN0aW9uIGRhdGVORGF5c0FnbyhudW1EYXlzQWdvKSB7XG4gIHJldHVybiBzaGlmdERhdGUobmV3IERhdGUoKSwgLW51bURheXNBZ28pO1xufVxuZnVuY3Rpb24gZ2V0UmFuZ2UoY291bnQpIHtcbiAgdmFyIGFyciA9IFtdO1xuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGNvdW50OyBpZHggKz0gMSkge1xuICAgIGFyci5wdXNoKGlkeCk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG52YXIgU1FVQVJFX1NJWkUgPSAxMDtcbnZhciBNT05USF9MQUJFTF9HVVRURVJfU0laRSA9IDQ7XG52YXIgQ1NTX1BTRURVT19OQU1FU1BBQ0UgPSAncmVhY3QtY2FsZW5kYXItaGVhdG1hcC0nO1xuXG52YXIgQ2FsZW5kYXJIZWF0bWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhDYWxlbmRhckhlYXRtYXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENhbGVuZGFySGVhdG1hcCgpIHtcbiAgICB2YXIgX2dldFByb3RvdHlwZU9mMjtcblxuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxlbmRhckhlYXRtYXApO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9nZXRQcm90b3R5cGVPZjIgPSBfZ2V0UHJvdG90eXBlT2YoQ2FsZW5kYXJIZWF0bWFwKSkuY2FsbC5hcHBseShfZ2V0UHJvdG90eXBlT2YyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZ2V0VmFsdWVDYWNoZVwiLCBtZW1vaXplT25lKGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgcmV0dXJuIHByb3BzLnZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRlID0gY29udmVydFRvRGF0ZSh2YWx1ZS5kYXRlKTtcbiAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcigoZGF0ZSAtIF90aGlzLmdldFN0YXJ0RGF0ZVdpdGhFbXB0eURheXMoKSkgLyBNSUxMSVNFQ09ORFNfSU5fT05FX0RBWSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXG4gICAgICAgIG1lbW9baW5kZXhdID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBjbGFzc05hbWU6IF90aGlzLnByb3BzLmNsYXNzRm9yVmFsdWUodmFsdWUpLFxuICAgICAgICAgIHRpdGxlOiBfdGhpcy5wcm9wcy50aXRsZUZvclZhbHVlID8gX3RoaXMucHJvcHMudGl0bGVGb3JWYWx1ZSh2YWx1ZSkgOiBudWxsLFxuICAgICAgICAgIHRvb2x0aXBEYXRhQXR0cnM6IF90aGlzLmdldFRvb2x0aXBEYXRhQXR0cnNGb3JWYWx1ZSh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCB7fSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhbGVuZGFySGVhdG1hcCwgW3tcbiAgICBrZXk6IFwiZ2V0RGF0ZURpZmZlcmVuY2VJbkRheXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0ZURpZmZlcmVuY2VJbkRheXMoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHN0YXJ0RGF0ZSA9IF90aGlzJHByb3BzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICBudW1EYXlzID0gX3RoaXMkcHJvcHMubnVtRGF5cztcblxuICAgICAgaWYgKG51bURheXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKCdudW1EYXlzIGlzIGEgZGVwcmVjYXRlZCBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgdGhlIHN0YXJ0RGF0ZSBwcm9wIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiBudW1EYXlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZURpZmYgPSB0aGlzLmdldEVuZERhdGUoKSAtIGNvbnZlcnRUb0RhdGUoc3RhcnREYXRlKTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGltZURpZmYgLyBNSUxMSVNFQ09ORFNfSU5fT05FX0RBWSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNxdWFyZVNpemVXaXRoR3V0dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNxdWFyZVNpemVXaXRoR3V0dGVyKCkge1xuICAgICAgcmV0dXJuIFNRVUFSRV9TSVpFICsgdGhpcy5wcm9wcy5ndXR0ZXJTaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNb250aExhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb250aExhYmVsU2l6ZSgpIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93TW9udGhMYWJlbHMpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmhvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIFNRVUFSRV9TSVpFICsgTU9OVEhfTEFCRUxfR1VUVEVSX1NJWkU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAyICogKFNRVUFSRV9TSVpFICsgTU9OVEhfTEFCRUxfR1VUVEVSX1NJWkUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXZWVrZGF5TGFiZWxTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdlZWtkYXlMYWJlbFNpemUoKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMuc2hvd1dlZWtkYXlMYWJlbHMpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmhvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU1FVQVJFX1NJWkUgKiAxLjU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXJ0RGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGFydERhdGUoKSB7XG4gICAgICByZXR1cm4gc2hpZnREYXRlKHRoaXMuZ2V0RW5kRGF0ZSgpLCAtdGhpcy5nZXREYXRlRGlmZmVyZW5jZUluRGF5cygpICsgMSk7IC8vICsxIGJlY2F1c2UgZW5kRGF0ZSBpcyBpbmNsdXNpdmVcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RW5kRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbmREYXRlKCkge1xuICAgICAgcmV0dXJuIGdldEJlZ2lubmluZ1RpbWVGb3JEYXRlKGNvbnZlcnRUb0RhdGUodGhpcy5wcm9wcy5lbmREYXRlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXJ0RGF0ZVdpdGhFbXB0eURheXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhcnREYXRlV2l0aEVtcHR5RGF5cygpIHtcbiAgICAgIHJldHVybiBzaGlmdERhdGUodGhpcy5nZXRTdGFydERhdGUoKSwgLXRoaXMuZ2V0TnVtRW1wdHlEYXlzQXRTdGFydCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TnVtRW1wdHlEYXlzQXRTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROdW1FbXB0eURheXNBdFN0YXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnREYXRlKCkuZ2V0RGF5KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE51bUVtcHR5RGF5c0F0RW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bUVtcHR5RGF5c0F0RW5kKCkge1xuICAgICAgcmV0dXJuIERBWVNfSU5fV0VFSyAtIDEgLSB0aGlzLmdldEVuZERhdGUoKS5nZXREYXkoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V2Vla0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdlZWtDb3VudCgpIHtcbiAgICAgIHZhciBudW1EYXlzUm91bmRlZFRvV2VlayA9IHRoaXMuZ2V0RGF0ZURpZmZlcmVuY2VJbkRheXMoKSArIHRoaXMuZ2V0TnVtRW1wdHlEYXlzQXRTdGFydCgpICsgdGhpcy5nZXROdW1FbXB0eURheXNBdEVuZCgpO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1EYXlzUm91bmRlZFRvV2VlayAvIERBWVNfSU5fV0VFSyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdlZWtXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXZWVrV2lkdGgoKSB7XG4gICAgICByZXR1cm4gREFZU19JTl9XRUVLICogdGhpcy5nZXRTcXVhcmVTaXplV2l0aEd1dHRlcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFdlZWtDb3VudCgpICogdGhpcy5nZXRTcXVhcmVTaXplV2l0aEd1dHRlcigpIC0gKHRoaXMucHJvcHMuZ3V0dGVyU2l6ZSAtIHRoaXMuZ2V0V2Vla2RheUxhYmVsU2l6ZSgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFdlZWtXaWR0aCgpICsgKHRoaXMuZ2V0TW9udGhMYWJlbFNpemUoKSAtIHRoaXMucHJvcHMuZ3V0dGVyU2l6ZSkgKyB0aGlzLmdldFdlZWtkYXlMYWJlbFNpemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVGb3JJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUZvckluZGV4KGluZGV4KSB7XG4gICAgICBpZiAodGhpcy52YWx1ZUNhY2hlW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUNhY2hlW2luZGV4XS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENsYXNzTmFtZUZvckluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsYXNzTmFtZUZvckluZGV4KGluZGV4KSB7XG4gICAgICBpZiAodGhpcy52YWx1ZUNhY2hlW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUNhY2hlW2luZGV4XS5jbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNsYXNzRm9yVmFsdWUobnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlRm9ySW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGVGb3JJbmRleChpbmRleCkge1xuICAgICAgaWYgKHRoaXMudmFsdWVDYWNoZVtpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVDYWNoZVtpbmRleF0udGl0bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnRpdGxlRm9yVmFsdWUgPyB0aGlzLnByb3BzLnRpdGxlRm9yVmFsdWUobnVsbCkgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb29sdGlwRGF0YUF0dHJzRm9ySW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbHRpcERhdGFBdHRyc0ZvckluZGV4KGluZGV4KSB7XG4gICAgICBpZiAodGhpcy52YWx1ZUNhY2hlW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUNhY2hlW2luZGV4XS50b29sdGlwRGF0YUF0dHJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXRUb29sdGlwRGF0YUF0dHJzRm9yVmFsdWUoe1xuICAgICAgICBkYXRlOiBudWxsLFxuICAgICAgICBjb3VudDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRvb2x0aXBEYXRhQXR0cnNGb3JWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb29sdGlwRGF0YUF0dHJzRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciB0b29sdGlwRGF0YUF0dHJzID0gdGhpcy5wcm9wcy50b29sdGlwRGF0YUF0dHJzO1xuXG4gICAgICBpZiAodHlwZW9mIHRvb2x0aXBEYXRhQXR0cnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBEYXRhQXR0cnModmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9vbHRpcERhdGFBdHRycztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJhbnNmb3JtRm9yV2Vla1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Gb3JXZWVrKHdlZWtJbmRleCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHdlZWtJbmRleCAqIHRoaXMuZ2V0U3F1YXJlU2l6ZVdpdGhHdXR0ZXIoKSwgXCIsIDApXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIuY29uY2F0KHdlZWtJbmRleCAqIHRoaXMuZ2V0U3F1YXJlU2l6ZVdpdGhHdXR0ZXIoKSwgXCIpXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFuc2Zvcm1Gb3JXZWVrZGF5TGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyYW5zZm9ybUZvcldlZWtkYXlMYWJlbHMoKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQoU1FVQVJFX1NJWkUsIFwiLCBcIikuY29uY2F0KHRoaXMuZ2V0TW9udGhMYWJlbFNpemUoKSwgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJhbnNmb3JtRm9yTW9udGhMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRm9yTW9udGhMYWJlbHMoKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQodGhpcy5nZXRXZWVrZGF5TGFiZWxTaXplKCksIFwiLCAwKVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0aGlzLmdldFdlZWtXaWR0aCgpICsgTU9OVEhfTEFCRUxfR1VUVEVSX1NJWkUsIFwiLCBcIikuY29uY2F0KHRoaXMuZ2V0V2Vla2RheUxhYmVsU2l6ZSgpLCBcIilcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRyYW5zZm9ybUZvckFsbFdlZWtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyYW5zZm9ybUZvckFsbFdlZWtzKCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRoaXMuZ2V0V2Vla2RheUxhYmVsU2l6ZSgpLCBcIiwgXCIpLmNvbmNhdCh0aGlzLmdldE1vbnRoTGFiZWxTaXplKCksIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsIFwiLmNvbmNhdCh0aGlzLmdldFdlZWtkYXlMYWJlbFNpemUoKSwgXCIpXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWV3Qm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdCb3goKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBcIjAgMCBcIi5jb25jYXQodGhpcy5nZXRXaWR0aCgpLCBcIiBcIikuY29uY2F0KHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIwIDAgXCIuY29uY2F0KHRoaXMuZ2V0SGVpZ2h0KCksIFwiIFwiKS5jb25jYXQodGhpcy5nZXRXaWR0aCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3F1YXJlQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3F1YXJlQ29vcmRpbmF0ZXMoZGF5SW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmhvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIFswLCBkYXlJbmRleCAqIHRoaXMuZ2V0U3F1YXJlU2l6ZVdpdGhHdXR0ZXIoKV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZGF5SW5kZXggKiB0aGlzLmdldFNxdWFyZVNpemVXaXRoR3V0dGVyKCksIDBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXZWVrZGF5TGFiZWxDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXZWVrZGF5TGFiZWxDb29yZGluYXRlcyhkYXlJbmRleCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gWzAsIChkYXlJbmRleCArIDEpICogU1FVQVJFX1NJWkUgKyBkYXlJbmRleCAqIHRoaXMucHJvcHMuZ3V0dGVyU2l6ZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZGF5SW5kZXggKiBTUVVBUkVfU0laRSArIGRheUluZGV4ICogdGhpcy5wcm9wcy5ndXR0ZXJTaXplLCBTUVVBUkVfU0laRV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1vbnRoTGFiZWxDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb250aExhYmVsQ29vcmRpbmF0ZXMod2Vla0luZGV4KSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBbd2Vla0luZGV4ICogdGhpcy5nZXRTcXVhcmVTaXplV2l0aEd1dHRlcigpLCB0aGlzLmdldE1vbnRoTGFiZWxTaXplKCkgLSBNT05USF9MQUJFTF9HVVRURVJfU0laRV07XG4gICAgICB9XG5cbiAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IC0yO1xuICAgICAgcmV0dXJuIFswLCAod2Vla0luZGV4ICsgMSkgKiB0aGlzLmdldFNxdWFyZVNpemVXaXRoR3V0dGVyKCkgKyB2ZXJ0aWNhbE9mZnNldF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DbGljayh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU1vdXNlT3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZU92ZXIoZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9uTW91c2VPdmVyKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Nb3VzZU92ZXIoZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3VzZUxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9uTW91c2VMZWF2ZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uTW91c2VMZWF2ZShlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclNxdWFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTcXVhcmUoZGF5SW5kZXgsIGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGluZGV4T3V0T2ZSYW5nZSA9IGluZGV4IDwgdGhpcy5nZXROdW1FbXB0eURheXNBdFN0YXJ0KCkgfHwgaW5kZXggPj0gdGhpcy5nZXROdW1FbXB0eURheXNBdFN0YXJ0KCkgKyB0aGlzLmdldERhdGVEaWZmZXJlbmNlSW5EYXlzKCk7XG5cbiAgICAgIGlmIChpbmRleE91dE9mUmFuZ2UgJiYgIXRoaXMucHJvcHMuc2hvd091dE9mUmFuZ2VEYXlzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkZ2V0U3F1YXJlQ29vcmRpID0gdGhpcy5nZXRTcXVhcmVDb29yZGluYXRlcyhkYXlJbmRleCksXG4gICAgICAgICAgX3RoaXMkZ2V0U3F1YXJlQ29vcmRpMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGdldFNxdWFyZUNvb3JkaSwgMiksXG4gICAgICAgICAgeCA9IF90aGlzJGdldFNxdWFyZUNvb3JkaTJbMF0sXG4gICAgICAgICAgeSA9IF90aGlzJGdldFNxdWFyZUNvb3JkaTJbMV07XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVGb3JJbmRleChpbmRleCk7XG4gICAgICB2YXIgcmVjdCA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9tb3VzZS1ldmVudHMtaGF2ZS1rZXktZXZlbnRzXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCBfZXh0ZW5kcyh7XG4gICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgIHdpZHRoOiBTUVVBUkVfU0laRSxcbiAgICAgICAgaGVpZ2h0OiBTUVVBUkVfU0laRSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmdldENsYXNzTmFtZUZvckluZGV4KGluZGV4KSxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmhhbmRsZUNsaWNrKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uIG9uTW91c2VPdmVyKGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmhhbmRsZU1vdXNlT3ZlcihlLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmhhbmRsZU1vdXNlTGVhdmUoZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLmdldFRvb2x0aXBEYXRhQXR0cnNGb3JJbmRleChpbmRleCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgdGhpcy5nZXRUaXRsZUZvckluZGV4KGluZGV4KSkpO1xuICAgICAgdmFyIHRyYW5zZm9ybURheUVsZW1lbnQgPSB0aGlzLnByb3BzLnRyYW5zZm9ybURheUVsZW1lbnQ7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtRGF5RWxlbWVudCA/IHRyYW5zZm9ybURheUVsZW1lbnQocmVjdCwgdmFsdWUsIGluZGV4KSA6IHJlY3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlcldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyV2Vlayh3ZWVrSW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgICBrZXk6IHdlZWtJbmRleCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmdldFRyYW5zZm9ybUZvcldlZWsod2Vla0luZGV4KSxcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChDU1NfUFNFRFVPX05BTUVTUEFDRSwgXCJ3ZWVrXCIpXG4gICAgICB9LCBnZXRSYW5nZShEQVlTX0lOX1dFRUspLm1hcChmdW5jdGlvbiAoZGF5SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5yZW5kZXJTcXVhcmUoZGF5SW5kZXgsIHdlZWtJbmRleCAqIERBWVNfSU5fV0VFSyArIGRheUluZGV4KTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQWxsV2Vla3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQWxsV2Vla3MoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgcmV0dXJuIGdldFJhbmdlKHRoaXMuZ2V0V2Vla0NvdW50KCkpLm1hcChmdW5jdGlvbiAod2Vla0luZGV4KSB7XG4gICAgICAgIHJldHVybiBfdGhpczQucmVuZGVyV2Vlayh3ZWVrSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlck1vbnRoTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck1vbnRoTGFiZWxzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93TW9udGhMYWJlbHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB3ZWVrUmFuZ2UgPSBnZXRSYW5nZSh0aGlzLmdldFdlZWtDb3VudCgpIC0gMSk7IC8vIGRvbid0IHJlbmRlciBmb3IgbGFzdCB3ZWVrLCBiZWNhdXNlIGxhYmVsIHdpbGwgYmUgY3V0IG9mZlxuXG4gICAgICByZXR1cm4gd2Vla1JhbmdlLm1hcChmdW5jdGlvbiAod2Vla0luZGV4KSB7XG4gICAgICAgIHZhciBlbmRPZldlZWsgPSBzaGlmdERhdGUoX3RoaXM1LmdldFN0YXJ0RGF0ZVdpdGhFbXB0eURheXMoKSwgKHdlZWtJbmRleCArIDEpICogREFZU19JTl9XRUVLKTtcblxuICAgICAgICB2YXIgX3RoaXM1JGdldE1vbnRoTGFiZWxDID0gX3RoaXM1LmdldE1vbnRoTGFiZWxDb29yZGluYXRlcyh3ZWVrSW5kZXgpLFxuICAgICAgICAgICAgX3RoaXM1JGdldE1vbnRoTGFiZWxDMiA9IF9zbGljZWRUb0FycmF5KF90aGlzNSRnZXRNb250aExhYmVsQywgMiksXG4gICAgICAgICAgICB4ID0gX3RoaXM1JGdldE1vbnRoTGFiZWxDMlswXSxcbiAgICAgICAgICAgIHkgPSBfdGhpczUkZ2V0TW9udGhMYWJlbEMyWzFdO1xuXG4gICAgICAgIHJldHVybiBlbmRPZldlZWsuZ2V0RGF0ZSgpID49IDEgJiYgZW5kT2ZXZWVrLmdldERhdGUoKSA8PSBEQVlTX0lOX1dFRUsgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCB7XG4gICAgICAgICAga2V5OiB3ZWVrSW5kZXgsXG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoQ1NTX1BTRURVT19OQU1FU1BBQ0UsIFwibW9udGgtbGFiZWxcIilcbiAgICAgICAgfSwgX3RoaXM1LnByb3BzLm1vbnRoTGFiZWxzW2VuZE9mV2Vlay5nZXRNb250aCgpXSkgOiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlcldlZWtkYXlMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyV2Vla2RheUxhYmVscygpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMucHJvcHMuc2hvd1dlZWtkYXlMYWJlbHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLndlZWtkYXlMYWJlbHMubWFwKGZ1bmN0aW9uICh3ZWVrZGF5TGFiZWwsIGRheUluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpczYkZ2V0V2Vla2RheUxhYmUgPSBfdGhpczYuZ2V0V2Vla2RheUxhYmVsQ29vcmRpbmF0ZXMoZGF5SW5kZXgpLFxuICAgICAgICAgICAgX3RoaXM2JGdldFdlZWtkYXlMYWJlMiA9IF9zbGljZWRUb0FycmF5KF90aGlzNiRnZXRXZWVrZGF5TGFiZSwgMiksXG4gICAgICAgICAgICB4ID0gX3RoaXM2JGdldFdlZWtkYXlMYWJlMlswXSxcbiAgICAgICAgICAgIHkgPSBfdGhpczYkZ2V0V2Vla2RheUxhYmUyWzFdO1xuXG4gICAgICAgIHZhciBjc3NDbGFzc2VzID0gXCJcIi5jb25jYXQoX3RoaXM2LnByb3BzLmhvcml6b250YWwgPyAnJyA6IFwiXCIuY29uY2F0KENTU19QU0VEVU9fTkFNRVNQQUNFLCBcInNtYWxsLXRleHRcIiksIFwiIFwiKS5jb25jYXQoQ1NTX1BTRURVT19OQU1FU1BBQ0UsIFwid2Vla2RheS1sYWJlbFwiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgICByZXR1cm4gZGF5SW5kZXggJiAxID8gUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRcIiwge1xuICAgICAgICAgIGtleTogXCJcIi5jb25jYXQoeCkuY29uY2F0KHkpLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBjbGFzc05hbWU6IGNzc0NsYXNzZXNcbiAgICAgICAgfSwgd2Vla2RheUxhYmVsKSA6IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMudmFsdWVDYWNoZSA9IHRoaXMuZ2V0VmFsdWVDYWNoZSh0aGlzLnByb3BzKTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWNhbGVuZGFyLWhlYXRtYXBcIixcbiAgICAgICAgdmlld0JveDogdGhpcy5nZXRWaWV3Qm94KClcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmdldFRyYW5zZm9ybUZvck1vbnRoTGFiZWxzKCksXG4gICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoQ1NTX1BTRURVT19OQU1FU1BBQ0UsIFwibW9udGgtbGFiZWxzXCIpXG4gICAgICB9LCB0aGlzLnJlbmRlck1vbnRoTGFiZWxzKCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5nZXRUcmFuc2Zvcm1Gb3JBbGxXZWVrcygpLFxuICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KENTU19QU0VEVU9fTkFNRVNQQUNFLCBcImFsbC13ZWVrc1wiKVxuICAgICAgfSwgdGhpcy5yZW5kZXJBbGxXZWVrcygpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgICB0cmFuc2Zvcm06IHRoaXMuZ2V0VHJhbnNmb3JtRm9yV2Vla2RheUxhYmVscygpLFxuICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KENTU19QU0VEVU9fTkFNRVNQQUNFLCBcIndlZWtkYXktbGFiZWxzXCIpXG4gICAgICB9LCB0aGlzLnJlbmRlcldlZWtkYXlMYWJlbHMoKSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYWxlbmRhckhlYXRtYXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkNhbGVuZGFySGVhdG1hcC5wcm9wVHlwZXMgPSB7XG4gIHZhbHVlczogcHJvcFR5cGVzLmFycmF5T2YocHJvcFR5cGVzLnNoYXBlKHtcbiAgICBkYXRlOiBwcm9wVHlwZXMub25lT2ZUeXBlKFtwcm9wVHlwZXMuc3RyaW5nLCBwcm9wVHlwZXMubnVtYmVyLCBwcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKV0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZCkuaXNSZXF1aXJlZCxcbiAgLy8gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGRhdGUgYW5kIGFyYml0cmFyeSBtZXRhZGF0YVxuICBudW1EYXlzOiBwcm9wVHlwZXMubnVtYmVyLFxuICAvLyBudW1iZXIgb2YgZGF5cyBiYWNrIGZyb20gZW5kRGF0ZSB0byBzaG93XG4gIHN0YXJ0RGF0ZTogcHJvcFR5cGVzLm9uZU9mVHlwZShbcHJvcFR5cGVzLnN0cmluZywgcHJvcFR5cGVzLm51bWJlciwgcHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSldKSxcbiAgLy8gc3RhcnQgb2YgZGF0ZSByYW5nZVxuICBlbmREYXRlOiBwcm9wVHlwZXMub25lT2ZUeXBlKFtwcm9wVHlwZXMuc3RyaW5nLCBwcm9wVHlwZXMubnVtYmVyLCBwcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKV0pLFxuICAvLyBlbmQgb2YgZGF0ZSByYW5nZVxuICBndXR0ZXJTaXplOiBwcm9wVHlwZXMubnVtYmVyLFxuICAvLyBzaXplIG9mIHNwYWNlIGJldHdlZW4gc3F1YXJlc1xuICBob3Jpem9udGFsOiBwcm9wVHlwZXMuYm9vbCxcbiAgLy8gd2hldGhlciB0byBvcmllbnQgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHlcbiAgc2hvd01vbnRoTGFiZWxzOiBwcm9wVHlwZXMuYm9vbCxcbiAgLy8gd2hldGhlciB0byBzaG93IG1vbnRoIGxhYmVsc1xuICBzaG93V2Vla2RheUxhYmVsczogcHJvcFR5cGVzLmJvb2wsXG4gIC8vIHdoZXRoZXIgdG8gc2hvdyB3ZWVrZGF5IGxhYmVsc1xuICBzaG93T3V0T2ZSYW5nZURheXM6IHByb3BUeXBlcy5ib29sLFxuICAvLyB3aGV0aGVyIHRvIHJlbmRlciBzcXVhcmVzIGZvciBleHRyYSBkYXlzIGluIHdlZWsgYWZ0ZXIgZW5kRGF0ZSwgYW5kIGJlZm9yZSBzdGFydCBkYXRlXG4gIHRvb2x0aXBEYXRhQXR0cnM6IHByb3BUeXBlcy5vbmVPZlR5cGUoW3Byb3BUeXBlcy5vYmplY3QsIHByb3BUeXBlcy5mdW5jXSksXG4gIC8vIGRhdGEgYXR0cmlidXRlcyB0byBhZGQgdG8gc3F1YXJlIGZvciBzZXR0aW5nIDNyZCBwYXJ0eSB0b29sdGlwcywgZS5nLiB7ICdkYXRhLXRvZ2dsZSc6ICd0b29sdGlwJyB9IGZvciBib290c3RyYXAgdG9vbHRpcHNcbiAgdGl0bGVGb3JWYWx1ZTogcHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGl0bGUgdGV4dCBmb3IgdmFsdWVcbiAgY2xhc3NGb3JWYWx1ZTogcHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgaHRtbCBjbGFzcyBmb3IgdmFsdWVcbiAgbW9udGhMYWJlbHM6IHByb3BUeXBlcy5hcnJheU9mKHByb3BUeXBlcy5zdHJpbmcpLFxuICAvLyBBbiBhcnJheSB3aXRoIDEyIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSB0ZXh0IGZyb20gamFudXJhcnkgdG8gZGVjZW1iZXJcbiAgd2Vla2RheUxhYmVsczogcHJvcFR5cGVzLmFycmF5T2YocHJvcFR5cGVzLnN0cmluZyksXG4gIC8vIEFuIGFycmF5IHdpdGggNyBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgdGV4dCBmcm9tIFN1biB0byBTYXRcbiAgb25DbGljazogcHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYSBzcXVhcmUgaXMgY2xpY2tlZFxuICBvbk1vdXNlT3ZlcjogcHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gbW91c2UgcG9pbnRlciBpcyBvdmVyIGEgc3F1YXJlXG4gIG9uTW91c2VMZWF2ZTogcHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gbW91c2UgcG9pbnRlciBpcyBsZWZ0IGEgc3F1YXJlXG4gIHRyYW5zZm9ybURheUVsZW1lbnQ6IHByb3BUeXBlcy5mdW5jIC8vIGZ1bmN0aW9uIHRvIGZ1cnRoZXIgdHJhbnNmb3JtIHRoZSBzdmcgZWxlbWVudCBmb3IgYSBzaW5nbGUgZGF5XG5cbn07XG5DYWxlbmRhckhlYXRtYXAuZGVmYXVsdFByb3BzID0ge1xuICBudW1EYXlzOiBudWxsLFxuICBzdGFydERhdGU6IGRhdGVORGF5c0FnbygyMDApLFxuICBlbmREYXRlOiBuZXcgRGF0ZSgpLFxuICBndXR0ZXJTaXplOiAxLFxuICBob3Jpem9udGFsOiB0cnVlLFxuICBzaG93TW9udGhMYWJlbHM6IHRydWUsXG4gIHNob3dXZWVrZGF5TGFiZWxzOiBmYWxzZSxcbiAgc2hvd091dE9mUmFuZ2VEYXlzOiBmYWxzZSxcbiAgdG9vbHRpcERhdGFBdHRyczogbnVsbCxcbiAgdGl0bGVGb3JWYWx1ZTogbnVsbCxcbiAgY2xhc3NGb3JWYWx1ZTogZnVuY3Rpb24gY2xhc3NGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/ICdjb2xvci1maWxsZWQnIDogJ2NvbG9yLWVtcHR5JztcbiAgfSxcbiAgbW9udGhMYWJlbHM6IE1PTlRIX0xBQkVMUyxcbiAgd2Vla2RheUxhYmVsczogREFZX0xBQkVMUyxcbiAgb25DbGljazogbnVsbCxcbiAgb25Nb3VzZU92ZXI6IG51bGwsXG4gIG9uTW91c2VMZWF2ZTogbnVsbCxcbiAgdHJhbnNmb3JtRGF5RWxlbWVudDogbnVsbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxlbmRhckhlYXRtYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1jYWxlbmRhci1oZWF0bWFwLmNqcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-calendar-heatmap/dist/react-calendar-heatmap.cjs.js\n");

/***/ })

};
;